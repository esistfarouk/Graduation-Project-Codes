/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "../Inc/LIB/STD_TYPES.h"
#include "../Inc/LIB/BIT_MATH.h"

#include "../Inc/MCAL/I2C/I2C_interface.h"
#include "../Inc/MCAL/RCC/RCC_int.h"
#include "../Inc/MCAL/NVIC/NVIC_interface.h"
#include "../Inc/MCAL/GPIO/GPIO_interface.h"
#include "../Inc/MCAL/STK/STK_interface.h"
#include "../Inc/MCAL/UART/UART_interface.h"
#include "../Inc/MCAL/ADC/ADC_interface.h"
#include "../Inc/MCAL/PWM/PWM_interface.h"

#define MOTORS_PWN_MAX_SPEED_VALUE 500
#define MOTORS_PWN_HALF_SPEED_VALUE 300

typedef enum
{
	none,joystick,eye,voice,remote
}control_modes;

void GetTamperature();
void ControlWheelchairUsingJoystick();
void WheelChair_Forward();
void WheelChair_Backward();
void WheelChair_Right();
void WheelChair_Left();
void WheelChair_Stop();
void WheelChair_RightForward();
void WheelChair_LeftForward();
void WheelChair_RightBackward();
void WheelChair_LeftBackward();
u8 compare_strings(u8 arr[],u8 arr1[]);

u8 Command_Raspberry[20];
u8 Command_Debug[20];
u8 Raspberry_command_flag = 0;
u8 Debug_command_flag = 0;
u8 Bluetooth_char = 0;
u8 Bluetooth_command_flag = 0;

//For MLX90614
f32 data = 20;
u8 temperature = 0;
u8 I2C_Data[3];

//For Joystick
u16 ADC_DATA_Y = 0;
u16 ADC_DATA_X = 0;

UART_Config_t Debug;
UART_Config_t Raspberry;
UART_Config_t Bluetooth;

void Init();
void GetDataFromRaspberryPi();
void GetDataFromBluetooth();

control_modes wheelchair_mode = none;

u8 first_time_none_flag = 1;
u8 first_time_eye_flag = 1;
u8 first_time_voice_flag = 1;
u8 first_time_joystick_flag = 1;
u8 first_time_remote_flag = 1;

int main(void)
{
	Init();
	while(1)
	{
		if(MDIO_u8GetPinValue(GPIO_U8_PORTA, GPIO_U8_PIN11)==0)
		{
			if(first_time_none_flag==1)
			{
				WheelChair_Stop();
				MUART_voidTransmitSync(&Debug, (u8* ) "None\r\n");
				MUART_voidTransmitSync(&Raspberry, (u8* ) "None\r");
				first_time_none_flag = 0;
				first_time_eye_flag = 1;
				first_time_voice_flag = 1;
				first_time_joystick_flag = 1;
				first_time_remote_flag = 1;
			}
			wheelchair_mode = none;
		}
		else if(MDIO_u8GetPinValue(GPIO_U8_PORTA, GPIO_U8_PIN12)==0)
		{
			if(first_time_joystick_flag==1)
			{
				WheelChair_Stop();
				MUART_voidTransmitSync(&Debug, (u8* ) "Joystick\r\n");
				MUART_voidTransmitSync(&Raspberry, (u8* ) "Joystick\r");
				first_time_none_flag = 1;
				first_time_eye_flag = 1;
				first_time_voice_flag = 1;
				first_time_joystick_flag = 0;
				first_time_remote_flag = 1;
			}
			wheelchair_mode = joystick;
		}
		else if(MDIO_u8GetPinValue(GPIO_U8_PORTA, GPIO_U8_PIN15)==0)
		{
			if(first_time_eye_flag==1)
			{
				WheelChair_Stop();
				MUART_voidTransmitSync(&Debug, (u8* ) "EYE\r\n");
				MUART_voidTransmitSync(&Raspberry, (u8* ) "eye\r");
				first_time_none_flag = 1;
				first_time_eye_flag = 0;
				first_time_voice_flag = 1;
				first_time_joystick_flag = 1;
				first_time_remote_flag = 1;
			}
			wheelchair_mode = eye;
		}
		else if(MDIO_u8GetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN4)==0)
		{
			if(first_time_remote_flag==1)
			{
				WheelChair_Stop();
				MUART_voidTransmitSync(&Debug, (u8* ) "Remote\r\n");
				MUART_voidTransmitSync(&Raspberry, (u8* ) "Remote\r");
				first_time_none_flag = 1;
				first_time_eye_flag = 1;
				first_time_voice_flag = 1;
				first_time_joystick_flag = 1;
				first_time_remote_flag = 0;
			}
			wheelchair_mode = remote;
		}
		else if(MDIO_u8GetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN5)==0)
		{
			if(first_time_none_flag==1)
			{
				WheelChair_Stop();
				MUART_voidTransmitSync(&Debug, (u8* ) "None\r\n");
				MUART_voidTransmitSync(&Raspberry, (u8* ) "None\r");
				first_time_none_flag = 0;
				first_time_eye_flag = 1;
				first_time_voice_flag = 1;
				first_time_joystick_flag = 1;
				first_time_remote_flag = 1;
			}
			wheelchair_mode = none;
		}
		else if(MDIO_u8GetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN3)==0)
		{
			if(first_time_voice_flag==1)
			{
				WheelChair_Stop();
				MUART_voidTransmitSync(&Debug, (u8* ) "VOICE\r\n");
				MUART_voidTransmitSync(&Raspberry, (u8* ) "voice\r");
				first_time_none_flag = 1;
				first_time_eye_flag = 1;
				first_time_voice_flag = 0;
				first_time_joystick_flag = 1;
				first_time_remote_flag = 1;
			}
			wheelchair_mode = voice;
		}
		if(wheelchair_mode==voice||wheelchair_mode==eye)
		{
			if(Raspberry_command_flag == 1)
			{
				if(compare_strings(Command_Raspberry, (u8* ) "Stop\r"))
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "STOP\r\n");
					WheelChair_Stop();
				}
				else if(compare_strings(Command_Raspberry, (u8* ) "Forward\r"))
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "FORWARD\r\n");
					WheelChair_Forward();
				}
				else if(compare_strings(Command_Raspberry, (u8* ) "Backward\r"))
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "BACKWARD\r\n");
					WheelChair_Backward();
				}
				else if(compare_strings(Command_Raspberry, (u8* ) "Right\r"))
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "RIGHT\r\n");
					WheelChair_Right();
				}
				else if(compare_strings(Command_Raspberry, (u8* ) "Left\r"))
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "LEFT\r\n");
					WheelChair_Left();
				}
				//MUART_voidTransmitSync(&Debug, Command_Raspberry);
				Raspberry_command_flag = 0;
			}

		}
		else if(wheelchair_mode==joystick)
		{
			ControlWheelchairUsingJoystick();
		}
		else if(wheelchair_mode==remote)
		{
			if(Bluetooth_command_flag == 1)
			{
				if(Bluetooth_char=='S')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "STOP\r\n");
					WheelChair_Stop();
				}
				else if(Bluetooth_char=='F')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "FORWARD\r\n");
					WheelChair_Forward();
				}
				else if(Bluetooth_char=='B')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "BACKWARD\r\n");
					WheelChair_Backward();
				}
				else if(Bluetooth_char=='R')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "RIGHT\r\n");
					WheelChair_Right();
				}
				else if(Bluetooth_char=='L')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "LEFT\r\n");
					WheelChair_Left();
				}
				else if(Bluetooth_char=='G')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "FORWARD LEFT\r\n");
					WheelChair_LeftForward();
				}
				else if(Bluetooth_char=='I')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "FORWARD RIGHT\r\n");
					WheelChair_RightForward();
				}
				else if(Bluetooth_char=='H')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "BACK LEFT\r\n");
					WheelChair_LeftBackward();
				}
				else if(Bluetooth_char=='J')
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "BACK RIGHT\r\n");
					WheelChair_RightBackward();
				}
				else
				{
					MUART_voidTransmitSync(&Debug, (u8* ) "STOP\r\n");
					WheelChair_Stop();
				}
				Bluetooth_command_flag = 0;
			}
		}
		else if(wheelchair_mode==none)
		{
			WheelChair_Stop();
		}
		else
		{
			WheelChair_Stop();
		}
		//GetTamperature();
	}
}
void GetDataFromRaspberryPi()
{
	static u8 counter = 0;
	u8 temp = MUART2_u8ReadDR();
	if(temp!='\n')
	{
		if(temp!='\r')
		{
			Command_Raspberry[counter]=temp;
			counter++;
		}
	}
	else
	{
		Raspberry_command_flag = 1;
		Command_Raspberry[counter]='\0';
		counter = 0;
	}
}
void GetDataFromBluetooth()
{
	//static u8 counter = 0;
	u8 temp = MUART3_u8ReadDR();
	Bluetooth_char = temp;
	Bluetooth_command_flag = 1;
	/*
	if(temp!='\n')
	{
		Command_Debug[counter]=temp;
		counter++;
	}
	else
	{
		Debug_command_flag = 1;
		Command_Debug[counter]='\0';
		counter = 0;
	}
	*/
}
void Init()
{
	Debug.UART_NUM=UART1;
	Debug.UART_ENABLE_STATE=UART_ENABLE;
	Debug.UART_WORD_LENGTH=UART_EIGHT_BITS;
	Debug.UART_WAKEUP=UART_IDLE_LINE;
	Debug.UART_PARITY_CONTROL_ENABLE=UART_PARITY_DISABLED;
	Debug.UART_PARITY_SELECTION=UART_EVEN_PARITY;
	Debug.UART_PEIE=UART_INTERRUPT_IS_INHIBITED_PE;
	Debug.UART_TXEIE=UART_INTERRUPT_IS_INHIBITED_TXE;
	Debug.UART_TCIE=UART_INTERRUPT_IS_INHIBITED_TC;
	Debug.UART_RXNEIE=UART_INTERRUPT_IS_INHIBITED_RXNE;
	Debug.UART_IDLEIE=UART_INTERRUPT_IS_INHIBITED_IDLE;
	Debug.UART_TE=UART_TRANSMITTER_ENABLE;
	Debug.UART_RE=UART_RECEIVER_ENABLE;
	Debug.UART_RWU=UART_RECEIVER_ACTIVE_MODE;
	Debug.UART_SBK=UART_NO_BREAK_CHARACTER;
	Debug.UART_BaudRate=9600;

	//UART Configuration for Raspberry pi communication
	Raspberry.UART_NUM=UART2;
	Raspberry.UART_ENABLE_STATE=UART_ENABLE;
	Raspberry.UART_WORD_LENGTH=UART_EIGHT_BITS;
	Raspberry.UART_WAKEUP=UART_IDLE_LINE;
	Raspberry.UART_PARITY_CONTROL_ENABLE=UART_PARITY_DISABLED;
	Raspberry.UART_PARITY_SELECTION=UART_EVEN_PARITY;
	Raspberry.UART_PEIE=UART_INTERRUPT_IS_INHIBITED_PE;
	Raspberry.UART_TXEIE=UART_INTERRUPT_IS_INHIBITED_TXE;
	Raspberry.UART_TCIE=UART_INTERRUPT_IS_INHIBITED_TC;
	Raspberry.UART_RXNEIE=UART_INTERRUPT_ENABLE_RXNE;
	Raspberry.UART_IDLEIE=UART_INTERRUPT_IS_INHIBITED_IDLE;
	Raspberry.UART_TE=UART_TRANSMITTER_ENABLE;
	Raspberry.UART_RE=UART_RECEIVER_ENABLE;
	Raspberry.UART_RWU=UART_RECEIVER_ACTIVE_MODE;
	Raspberry.UART_SBK=UART_NO_BREAK_CHARACTER;
	Raspberry.UART_BaudRate=9600;

	//UART Configuration for Bluetooth communication
	Bluetooth.UART_NUM=UART3;
	Bluetooth.UART_ENABLE_STATE=UART_ENABLE;
	Bluetooth.UART_WORD_LENGTH=UART_EIGHT_BITS;
	Bluetooth.UART_WAKEUP=UART_IDLE_LINE;
	Bluetooth.UART_PARITY_CONTROL_ENABLE=UART_PARITY_DISABLED;
	Bluetooth.UART_PARITY_SELECTION=UART_EVEN_PARITY;
	Bluetooth.UART_PEIE=UART_INTERRUPT_IS_INHIBITED_PE;
	Bluetooth.UART_TXEIE=UART_INTERRUPT_IS_INHIBITED_TXE;
	Bluetooth.UART_TCIE=UART_INTERRUPT_IS_INHIBITED_TC;
	Bluetooth.UART_RXNEIE=UART_INTERRUPT_ENABLE_RXNE;
	Bluetooth.UART_IDLEIE=UART_INTERRUPT_IS_INHIBITED_IDLE;
	Bluetooth.UART_TE=UART_TRANSMITTER_ENABLE;
	Bluetooth.UART_RE=UART_RECEIVER_ENABLE;
	Bluetooth.UART_RWU=UART_RECEIVER_ACTIVE_MODE;
	Bluetooth.UART_SBK=UART_NO_BREAK_CHARACTER;
	Bluetooth.UART_BaudRate=9600;

	/*Initializing RCC and Clocks for Peripherals*/
    MRCC_voidInit();
    MRCC_voidControlPeripheralsClock(APB2, IOPA, ENABLE_PERIPHERAL);
    MRCC_voidControlPeripheralsClock(APB2, IOPB, ENABLE_PERIPHERAL);
    MRCC_voidControlPeripheralsClock(APB1, I2C1, ENABLE_PERIPHERAL);
    MRCC_voidControlPeripheralsClock(APB2, ADC1, ENABLE_PERIPHERAL);
    MRCC_voidControlPeripheralsClock(APB1, TIM3, ENABLE_PERIPHERAL);
	MRCC_voidControlPeripheralsClock(APB1, USART3, ENABLE_PERIPHERAL);
	MRCC_voidControlPeripheralsClock(APB1, USART2, ENABLE_PERIPHERAL);
	MRCC_voidControlPeripheralsClock(APB2, USART1, ENABLE_PERIPHERAL);

	//MotorDrivers Pins
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_OUTPUT_PP_2MHZ);  //right motor cw
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_OUTPUT_PP_2MHZ);  //right motor ccw
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_OUTPUT_PP_2MHZ); //left motor cw
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_OUTPUT_PP_2MHZ); //left motor ccw

	//Selector Pins input pull up/down
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN11, GPIO_U8_INPUT_PULL_UP_DOWN);
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN12, GPIO_U8_INPUT_PULL_UP_DOWN);
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN15, GPIO_U8_INPUT_PULL_UP_DOWN);
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN3, GPIO_U8_INPUT_PULL_UP_DOWN);
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN4, GPIO_U8_INPUT_PULL_UP_DOWN);
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN5, GPIO_U8_INPUT_PULL_UP_DOWN);

	//pull up
	MDIO_voidSetPinValue(GPIO_U8_PORTA, GPIO_U8_PIN11, GPIO_U8_HIGH);
	MDIO_voidSetPinValue(GPIO_U8_PORTA, GPIO_U8_PIN12, GPIO_U8_HIGH);
	MDIO_voidSetPinValue(GPIO_U8_PORTA, GPIO_U8_PIN15, GPIO_U8_HIGH);
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN3, GPIO_U8_HIGH);
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN4, GPIO_U8_HIGH);
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN5, GPIO_U8_HIGH);

	//PWM Pins (TIM3 Channel 1 and Channel 2)
    MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN6, GPIO_U8_OUTPUT_AF_PP_2MHZ); //right motor speed
    MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN7, GPIO_U8_OUTPUT_AF_PP_2MHZ); //left motor speed

    //ADC Pins (Channel 0 and Channel 1)
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN0, GPIO_U8_INPUT_ANALOG);
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN1, GPIO_U8_INPUT_ANALOG);

	//I2C1 Pins
    //MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN6, GPIO_U8_OUTPUT_AF_OD_2MHZ);
    //MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN7, GPIO_U8_OUTPUT_AF_OD_2MHZ);

    //UART3 Pins
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN10, GPIO_U8_OUTPUT_AF_PP_2MHZ);
	MDIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN11, GPIO_U8_INPUT_FLOATING);
	//UART2 Pins
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN2, GPIO_U8_OUTPUT_AF_PP_2MHZ);
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN3, GPIO_U8_INPUT_FLOATING);
	//UART1 Pins
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN9, GPIO_U8_OUTPUT_AF_PP_2MHZ);
	MDIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN10, GPIO_U8_INPUT_FLOATING);

	MUART_voidInit(&Debug);
	MUART_voidInit(&Raspberry);
	MUART_voidInit(&Bluetooth);

	MPWM_voidInit();
	MSTK_voidInit();

	//UART2, UART3 Enable Interrupt
	MNVIC_voidInit();
	MNVIC_voidEnableInterrupt(38); //UART2
	MUART2_voidSetCallBack(GetDataFromRaspberryPi);
	MNVIC_voidEnableInterrupt(39); //UART3
	MUART3_voidSetCallBack(GetDataFromBluetooth);

	MADC1_voidInit();

    //MI2C_MasterInit();

}
void GetTamperature()
{
	//MLX90614
	MI2C_wait();
	MasterSendStartCondition();
	MI2C_MasterTransmitAddress(0x5A, Write);
	MI2C_MasterTransmitData(0x07);
	MasterSendStartCondition();
	MI2C_MasterTransmitAddress(0x5A, Read);
	MI2C_MasterRecieve_ThreeBytes(I2C_Data);
	data = (I2C_Data[1]<<8|I2C_Data[0])*0.02;
	temperature=data-273;
	MUART_voidTransmitSync(&Debug, (u8* )"Temperature: ");
	MUART_voidSendInteger(&Debug, temperature);
	MUART_voidTransmitCharSync(&Debug, '\r');
	MUART_voidTransmitCharSync(&Debug, '\n');
}
void ControlWheelchairUsingJoystick()
{
	//ADC
	ADC_DATA_Y = MADC1_u16StartConversion_Channel_0();
	ADC_DATA_X = MADC1_u16StartConversion_Channel_1();
	if(ADC_DATA_Y>3072)
	{
		if(ADC_DATA_X>3072)
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "RIGHT FORWARD\r\n");
			WheelChair_RightForward();
		}
		else if(ADC_DATA_X<1024)
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "LEFT FORWARD\r\n");
			WheelChair_LeftForward();
		}
		else
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "FORWARD\r\n");
			WheelChair_Forward();
		}
	}
	else if(ADC_DATA_Y<1024)
	{
		if(ADC_DATA_X>3072)
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "RIGHT BACKWARD\r\n");
			WheelChair_RightBackward();
		}
		else if(ADC_DATA_X<1024)
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "LEFT BACKWARD\r\n");
			WheelChair_LeftBackward();
		}
		else
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "BACKWARD\r\n");
			WheelChair_Backward();
		}
	}
	else
	{
		if(ADC_DATA_X>3072)
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "RIGHT\r\n");
			WheelChair_Right();
		}
		else if(ADC_DATA_X<1024)
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "LEFT\r\n");
			WheelChair_Left();
		}
		else
		{
			MUART_voidTransmitSync(&Debug, (u8* ) "STOP\r\n");
			WheelChair_Stop();
		}
	}
}
void WheelChair_Forward()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_HIGH);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_LOW);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_HIGH); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_LOW); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //left motor speed
}
void WheelChair_Backward()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_LOW);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_HIGH);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_LOW); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_HIGH); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //left motor speed
}
void WheelChair_Right()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_LOW);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_HIGH);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_HIGH); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_LOW); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //left motor speed
}
void WheelChair_Left()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_HIGH);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_LOW);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_LOW); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_HIGH); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //left motor speed
}
void WheelChair_Stop()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_LOW);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_LOW);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_LOW); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_LOW); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(0); //right motor speed
	MPWM_voidChannel_2_SetValue(0); //left motor speed
}
void WheelChair_RightForward()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_HIGH);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_LOW);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_HIGH); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_LOW); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_HALF_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //left motor speed
}
void WheelChair_LeftForward()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_HIGH);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_LOW);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_HIGH); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_LOW); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_HALF_SPEED_VALUE); //left motor speed
}
void WheelChair_RightBackward()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_LOW);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_HIGH);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_LOW); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_HIGH); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_HALF_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //left motor speed
}
void WheelChair_LeftBackward()
{
	//MotorDrivers Pins
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN12, GPIO_U8_LOW);  //right motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN13, GPIO_U8_HIGH);  //right motor ccw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN14, GPIO_U8_LOW); //left motor cw
	MDIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN15, GPIO_U8_HIGH); //left motor ccw
	//PWM Pins (TIM3 Channel 1 and Channel 2)
	MPWM_voidChannel_1_SetValue(MOTORS_PWN_MAX_SPEED_VALUE); //right motor speed
	MPWM_voidChannel_2_SetValue(MOTORS_PWN_HALF_SPEED_VALUE); //left motor speed
}
u8 compare_strings(u8 arr[],u8 arr1[])
{
	u8 index=0;
	u8 rightflag=0;
	while(arr[index] != '\0')
	{
		if(arr[index]==arr1[index])
		{
			rightflag=1;
			index++;
		}
		else
		{
			rightflag=0;
			break;
		}
	}
	return rightflag;
}
